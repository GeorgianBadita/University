{
  "_args": [
    [
      {
        "raw": "mobx-state-tree",
        "scope": null,
        "escapedName": "mobx-state-tree",
        "name": "mobx-state-tree",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\Users\\georg\\Desktop\\University\\Semester5\\Mobile"
    ]
  ],
  "_from": "mobx-state-tree",
  "_hasShrinkwrap": false,
  "_id": "mobx-state-tree@3.14.1",
  "_location": "/mobx-state-tree",
  "_nodeVersion": "10.15.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/mobx-state-tree_3.14.1_1563565098064_0.18547558231443162"
  },
  "_npmUser": {
    "name": "mweststrate",
    "email": "mweststrate@gmail.com"
  },
  "_npmVersion": "lerna/3.15.0/node@v10.15.1+x64 (linux)",
  "_phantomChildren": {},
  "_requested": {
    "raw": "mobx-state-tree",
    "scope": null,
    "escapedName": "mobx-state-tree",
    "name": "mobx-state-tree",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/mobx-state-tree/-/mobx-state-tree-3.14.1.tgz",
  "_shasum": "0a523876b87817f5c8553a162e71b38044f0c9da",
  "_shrinkwrap": null,
  "_spec": "mobx-state-tree",
  "_where": "C:\\Users\\georg\\Desktop\\University\\Semester5\\Mobile",
  "author": {
    "name": "Michel Weststrate"
  },
  "browser": {
    "./dist/mobx-state-tree.js": "./dist/mobx-state-tree.js",
    "./dist/mobx-state-tree.module.js": "./dist/mobx-state-tree.module.js"
  },
  "bugs": {
    "url": "https://github.com/mobxjs/mobx-state-tree/issues"
  },
  "dependencies": {},
  "description": "Opinionated, transactional, MobX powered state container",
  "devDependencies": {
    "@types/jest": "^24.0.11",
    "@types/node": "^12.0.2",
    "concat": "^1.0.3",
    "coveralls": "^3.0.3",
    "cpr": "^3.0.1",
    "cross-env": "^5.2.0",
    "jest": "^24.5.0",
    "jest-junit": "^6.3.0",
    "mobx": "^5.9.0",
    "rollup": "^1.6.0",
    "rollup-plugin-commonjs": "^10.0.0",
    "rollup-plugin-filesize": "^6.0.1",
    "rollup-plugin-node-resolve": "^5.0.0",
    "rollup-plugin-replace": "^2.1.0",
    "rollup-plugin-terser": "^5.0.0",
    "shx": "^0.3.2",
    "spec.ts": "^1.1.3",
    "ts-jest": "^24.0.0",
    "ts-node": "^8.0.3",
    "tslib": "^1.9.3",
    "tslint": "^5.14.0",
    "typedoc": "^0.14.2",
    "typedoc-plugin-markdown": "^1.1.27",
    "typescript": "^3.5.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-cmwO1jvYPgaJTGJtqId0Qod4cDqcJEWWCwSu/Uns7jFT+kWKzLFhzb9jxPub8YM3HSXg7HPGpKiLe970he9FOw==",
    "shasum": "0a523876b87817f5c8553a162e71b38044f0c9da",
    "tarball": "https://registry.npmjs.org/mobx-state-tree/-/mobx-state-tree-3.14.1.tgz",
    "fileCount": 47,
    "unpackedSize": 1109976,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdMhwrCRA9TVsSAnZWagAAABEP+wYaKS7gtrP7fLU30PgF\nFhVtteD2mLNEE6Kn4zd9btEF19VB91wDLCEiD3oqccWPwxSZLSxwq631zk8G\njnu8bQTfbMcWxIdz9Gtp/yOn3G/WOcrtOOKFq5HaSbI+Ul3yDDjazP/rMhbx\nKaMgQSu2mwI8KrsxW8iA9/MlRAV80jWQ4VlxrDKAH22luBvaGa0bEoVj8FxF\nxdeDVnbwlrJWMWWJdFrSJjEuerjv5+Mn98FCsDOIMe/QuI+UaMc60mjFwL3v\nib3kfDF6iRLr7JZW5ZhKGSQ3fsSkVetPYPjXDg77un6GAqyWsgGyIJzq04On\njK8n34CO8vtYPTVpiwksZe0F8SzIXQsUNyQwLKrAZary6iS4W5hyr/894wbW\n0dMbuvKGlHUcacShf/C0DT6c4cytBYfgEcHIre8XvELf54qZfep0F5k/5+v+\nhFsUREL2UDr3m44bMP9bQGGHej4POhrHZ+E52O9csDlaDapkmnOv66DDamVy\n6YowAhrBnTQRtaXh74zSTaKH9+kjl8kQa+GZuRrL69bK38TOSNwEl7b/TLX6\nhyuNlV+lAHmo8cRWq1uomybBUqwmbdiDMQsLZVGXYPDa2tS/0R924LU1bTad\nNG2GekZvo01YCWywzdFG6nGT0EvsKwlkqjgHmklfUYihhxgd64p8uwoaZLxH\nN/am\r\n=7zmx\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "dist/"
  ],
  "gitHead": "8ef9c35db90314ceeac27d73052f01fd0f8cf9eb",
  "homepage": "https://github.com/mobxjs/mobx-state-tree#readme",
  "jsnext:main": "dist/mobx-state-tree.module.js",
  "keywords": [
    "mobx",
    "mobx-state-tree",
    "promise",
    "reactive",
    "frp",
    "functional-reactive-programming",
    "state management"
  ],
  "license": "MIT",
  "main": "dist/mobx-state-tree.js",
  "maintainers": [
    {
      "name": "mattiamanzati",
      "email": "manzati.mattia@gmail.com"
    },
    {
      "name": "mweststrate",
      "email": "mweststrate@gmail.com"
    },
    {
      "name": "xaviergonz",
      "email": "xaviergonz@gmail.com"
    }
  ],
  "module": "dist/mobx-state-tree.module.js",
  "name": "mobx-state-tree",
  "optionalDependencies": {},
  "peerDependencies": {
    "mobx": ">=4.8.0 <5.0.0 || >=5.8.0 <6.0.0"
  },
  "react-native": "dist/mobx-state-tree.module.js",
  "readme": "<img src=\"docs/mobx-state-tree-logo-gradient.png\" alt=\"logo\" height=\"120\" align=\"right\" />\n\n# mobx-state-tree\n\n_Opinionated, transactional, MobX powered state container combining the best features of the immutable and mutable world for an optimal DX_\n\n[![npm version](https://badge.fury.io/js/mobx-state-tree.svg)](https://badge.fury.io/js/mobx-state-tree)\n[![CircleCI](https://circleci.com/gh/mobxjs/mobx-state-tree.svg?style=svg)](https://circleci.com/gh/mobxjs/mobx-state-tree)\n[![Coverage Status](https://coveralls.io/repos/github/mobxjs/mobx-state-tree/badge.svg?branch=master)](https://coveralls.io/github/mobxjs/mobx-state-tree?branch=master)\n[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/mobx-state-tree)\n\n> Mobx and MST are amazing pieces of software, for me it is the missing brick when you build React based apps. Thanks for the great work!\n\nNicolas Galle [full post](https://medium.com/@nicolasgall/i-started-to-use-react-last-year-and-i-loved-it-1ce8d53fec6a)\nIntroduction blog post [The curious case of MobX state tree](https://medium.com/@mweststrate/the-curious-case-of-mobx-state-tree-7b4e22d461f)\n\n---\n\nMobX state tree is a community driven project, but is looking for active maintainers! See [#700](https://github.com/mobxjs/mobx-state-tree/issues/700)\n\n---\n\n# Contents\n\n-   [Changelog](changelog.md)\n-   [Installation](#installation)\n-   [Getting Started](docs/getting-started.md)\n-   [Talks & blogs](#talks--blogs)\n-   [Philosophy & Overview](#philosophy--overview)\n-   [Examples](#examples)\n-   [Concepts](#concepts)\n    -   [Trees, types and state](#trees-types-and-state)\n    -   [Creating models](#creating-models)\n    -   [Tree semantics in detail](#tree-semantics-in-detail)\n    -   [Composing trees](#composing-trees)\n    -   [Actions](#actions)\n    -   [Views](#views)\n    -   [Snapshots](#snapshots)\n    -   [Patches](#patches)\n    -   [References and identifiers](#references-and-identifiers)\n    -   [Listening to observables, snapshots, patches or actions](#listening-to-observables-snapshots-patches-or-actions)\n    -   [Volatile state](#volatile-state)\n    -   [Dependency injection](#dependency-injection)\n-   [Types overview](#types-overview)\n    -   [Lifecycle hooks](#lifecycle-hooks-for-typesmodel)\n-   [Api overview](#api-overview)\n-   [Tips](#tips)\n-   [FAQ](#faq)\n-   [Full Api Docs](docs/API/README.md)\n-   [Built-in / example middlewares](packages/mst-middlewares/README.md)\n\n# Installation\n\n-   NPM: `npm install mobx mobx-state-tree --save`\n-   Yarn: `yarn add mobx mobx-state-tree`\n-   CDN: https://unpkg.com/mobx-state-tree/dist/mobx-state-tree.umd.js (exposed as `window.mobxStateTree`)\n-   CodeSandbox [TodoList demo](https://codesandbox.io/s/y64pzxj01) fork for testing and bug reporting\n-   Playground: _(warning: uses an old version of MST)_ [https://mattiamanzati.github.io/mobx-state-tree-playground/](https://mattiamanzati.github.io/mobx-state-tree-playground/) (with React UI, snapshots, patches and actions display)\n\nTypescript typings are included in the packages. Use `module: \"commonjs\"` or `moduleResolution: \"node\"` to make sure they are picked up automatically in any consuming project.\n\nSupported browsers:\n\n-   MobX-state-tree runs on any ES5 environment\n-   However, for MobX version 4 or 5 can be used. MobX 4 will run on any environment, MobX 5 only on modern browsers. See for more details the [MobX readme](https://github.com/mobxjs/mobx#browser-support)\n\n# Getting started\n\nSee the [Getting started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started) tutorial or follow the free [egghead.io course](https://egghead.io/courses/manage-application-state-with-mobx-state-tree) (note however that the course is for MST v2, so it might be a bit outdated).\n\n# Talks & blogs\n\n-   Talk React Europe 2017: [Next generation state management](https://www.youtube.com/watch?v=rwqwwn_46kA)\n-   Talk ReactNext 2017: [React, but for Data](https://www.youtube.com/watch?v=xfC_xEA8Z1M&index=6&list=PLMYVq3z1QxSqq6D7jxVdqttOX7H_Brq8Z) ([slides](http://react-next-2017-slides.surge.sh/#1), [demo](https://codesandbox.io/s/8y4p23j32j))\n-   Talk ReactJSDay Verona 2017: [Immutable or immutable? Both!](https://www.youtube.com/watch?v=zdtwaa5Rmb8&index=9&list=PLWK9j6ps_unl293VhhN4RYMCISxye3xH9) ([slides](https://mweststrate.github.io/reactjsday2017-presentation/index.html#1), [demo](https://github.com/mweststrate/reatjsday2017-demo))\n-   Talk React Alicante 2017: [Mutable or Immutable? Let's do both!](https://www.youtube.com/watch?v=DgnL3uij9ec&list=PLd7nkr8mN0sWvBH_s0foCE6eZTX8BmLUM&index=9) ([slides](https://mattiamanzati.github.io/slides-react-alicante-2017/#2))\n-   Talk ReactiveConf 2016: [Immer-mutable state management](https://www.youtube.com/watch?v=Ql8KUUUOHNc&list=PLa2ZZ09WYepMCRRGCRPhTYuTCat4TiDlX&index=30)\n-   Talk FrontendLove 2018: [MobX State Tree + React: pure reactivity served](https://www.youtube.com/watch?v=HS9revHrNRI) by [Luca Mezzalira](https://lucamezzalira.com/) ([slides](https://docs.google.com/presentation/d/1f18RhN9hz1GPAdY4binWVNZDKm3k7EfNvV48lWnzdjQ/edit#slide=id.g35f391192_00)).\n\n# Philosophy & Overview\n\n`mobx-state-tree` is a state container that combines the _simplicity and ease of mutable data_ with the _traceability of immutable data_ and the _reactiveness and performance of observable data_.\n\nSimply put, mobx-state-tree tries to combine the best features of both immutability (transactionality, traceability and composition) and mutability (discoverability, co-location and encapsulation) based approaches to state management; everything to provide the best developer experience possible.\nUnlike MobX itself, mobx-state-tree is very opinionated about how data should be structured and updated.\nThis makes it possible to solve many common problems out of the box.\n\nCentral in MST (mobx-state-tree) is the concept of a _living tree_. The tree consists of mutable, but strictly protected objects enriched with _runtime type information_. In other words, each tree has a _shape_ (type information) and _state_ (data).\nFrom this living tree, immutable, structurally shared, snapshots are automatically generated.\n\n```javascript\nimport { types, onSnapshot } from \"mobx-state-tree\"\n\nconst Todo = types\n    .model(\"Todo\", {\n        title: types.string,\n        done: false\n    })\n    .actions(self => ({\n        toggle() {\n            self.done = !self.done\n        }\n    }))\n\nconst Store = types.model(\"Store\", {\n    todos: types.array(Todo)\n})\n\n// create an instance from a snapshot\nconst store = Store.create({\n    todos: [\n        {\n            title: \"Get coffee\"\n        }\n    ]\n})\n\n// listen to new snapshots\nonSnapshot(store, snapshot => {\n    console.dir(snapshot)\n})\n\n// invoke action that modifies the tree\nstore.todos[0].toggle()\n// prints: `{ todos: [{ title: \"Get coffee\", done: true }]}`\n```\n\nBy using the type information available, snapshots can be converted to living trees, and vice versa, with zero effort.\nBecause of this, [time travelling](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-example-boxes/src/stores/time.js) is supported out of the box, and tools like HMR are trivial to support [example](https://github.com/mobxjs/mobx-state-tree/blob/4c2b19ec4a6a8d74064e4b8a87c0f8b46e97e621/examples/boxes/src/stores/domain-state.js#L94).\n\nThe type information is designed in such a way that it is used both at design- and run-time to verify type correctness (Design time type checking works in TypeScript only at the moment; Flow PR's are welcome!)\n\n```\n[mobx-state-tree] Value '{\\\"todos\\\":[{\\\"turtle\\\":\\\"Get tea\\\"}]}' is not assignable to type: Store, expected an instance of Store or a snapshot like '{ todos: { title: string; done: boolean }[] }' instead.\n```\n\n_Runtime type error_\n\n![typescript error](docs/tserror.png)\n\n_Designtime type error_\n\nBecause state trees are living, mutable models, actions are straight-forward to write; just modify local instance properties where appropriate. See `toggleTodo()` above or the examples below. It is not necessary to produce a new state tree yourself, MST's snapshot functionality will derive one for you automatically.\n\nAlthough mutable sounds scary to some, fear not, actions have many interesting properties.\nBy default trees can only be modified by using an action that belongs to the same subtree.\nFurthermore, actions are replayable and can be used to distribute changes ([example](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-example-boxes/src/stores/socket.js)).\n\nMoreover, because changes can be detected on a fine grained level, JSON patches are supported out of the box.\nSimply subscribing to the patch stream of a tree is another way to sync diffs with, for example, back-end servers or other clients ([example](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-example-boxes/src/stores/socket.js)).\n\n![patches](docs/patches.png)\n\nSince MST uses MobX behind the scenes, it integrates seamlessly with [mobx](https://mobx.js.org) and [mobx-react](https://github.com/mobxjs/mobx-react). See also this [egghead.io lesson: Render mobx-state-tree Models in React](https://egghead.io/lessons/react-render-mobx-state-tree-models-in-react).\nEven cooler, because it supports snapshots, middleware and replayable actions out of the box, it is possible to replace a Redux store and reducer with a MobX state tree.\nThis makes it possible to connect the Redux devtools to MST. See the [Redux / MST TodoMVC example](https://github.com/mobxjs/mobx-state-tree/blob/1906a394906d2e8f2cc1c778e1e3228307c1b112/packages/mst-example-redux-todomvc/src/index.js#L6).\n\n---\n\nFor futher reading: the conceptual difference between snapshots, patches and actions in relation to distributing state changes is extensively discussed in this [blog post](https://medium.com/@mweststrate/distributing-state-changes-using-snapshots-patches-and-actions-part-1-2811a2fcd65f)\n\n![devtools](docs/reduxdevtools.png)\n\nFinally, MST has built-in support for references, identifiers, dependency injection, change recording and circular type definitions (even across files).\nEven fancier, it analyses liveliness of objects, failing early when you try to access accidentally cached information! (More on that later)\n\nA unique feature of MST is that it offers liveliness guarantees. MST will throw when reading or writing from objects that are no longer part of a state tree. This protects you against accidental stale reads of objects still referred by, for example, a closure.\n\n```javascript\nconst oldTodo = store.todos[0]\nstore.removeTodo(0)\n\nfunction logTodo(todo) {\n    setTimeout(() => console.log(todo.title), 1000)\n}\n\nlogTodo(store.todos[0])\nstore.removeTodo(0)\n// throws exception in one second for using an stale object!\n```\n\nDespite all that, you will see that the [API](docs/API/README.md) is quite straightforward!\n\n---\n\nAnother way to look at mobx-state-tree is to consider it, as argued by Daniel Earwicker, to be [\"React, but for data\"](http://danielearwicker.github.io/json_mobx_Like_React_but_for_Data_Part_2.html).\nLike React, MST consists of composable components, called _models_, which captures a small piece of state. They are instantiated from props (snapshots) and after that manage and protect their own internal state (using actions). Moreover, when applying snapshots, tree nodes are reconciled as much as possible. There is even a context-like mechanism, called environments, to pass information to deep descendants.\n\nAn introduction to the philosophy can be watched [here](https://youtu.be/ta8QKmNRXZM?t=21m52s). [Slides](https://immer-mutable-state.surge.sh/). Or, as [markdown](https://github.com/mweststrate/reactive2016-slides/blob/master/slides.md) to read it quickly.\n\nmobx-state-tree \"immutable trees\" and \"graph model\" features talk, [\"Next Generation State Management\"](https://www.youtube.com/watch?v=rwqwwn_46kA) at React Europe 2017. [Slides](http://tree.surge.sh/#1).\n\n# Examples\n\nTo run the examples:\n\n1.  clone this repository\n2.  navigate to the example folder (e.g. `packages/mst-example-bookshop`)\n3.  run `yarn install` and `yarn start`\n\n-   [Bookshop](https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-bookshop) Example webshop application with references, identifiers, routing, testing, etc.\n-   [Boxes](https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-boxes) Example app where one can draw, drag, and drop boxes. With time-travelling and multi-client synchronization over websockets.\n-   [TodoMVC](https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-todomvc) Classic example app using React and MST.\n-   [Redux TodoMVC](https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-redux-todomvc) Redux TodoMVC application, except that the reducers are replaced with a MST. Tip: open the Redux devtools; they will work!\n\n# Concepts\n\nWith MobX state tree, you build, as the name suggests, trees of models.\n\n### Trees, types and state\n\nEach **node** in the tree is described by two things: Its **type** (the shape of the thing) and its **data** (the state it is currently in).\n\nThe simplest tree possible:\n\n```javascript\nimport { types } from \"mobx-state-tree\"\n\n// declaring the shape of a node with the type `Todo`\nconst Todo = types.model({\n    title: types.string\n})\n\n// creating a tree based on the \"Todo\" type, with initial data:\nconst coffeeTodo = Todo.create({\n    title: \"Get coffee\"\n})\n```\n\nThe `types.model` type declaration is used to describe the shape of an object.\nOther built-in types include arrays, maps, primitives, etc. See the [types overview](#types-overview).\nThe type information will be used for both.\n\n### Creating models\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-describe-your-application-domain-using-mobx-state-tree-mst-models\">egghead.io lesson 1: Describe Your Application Domain Using mobx-state-tree(MST) Models</a></i>\n\nThe most important type in MST is `types.model`, which can be used to describe the shape of an object.\nAn example:\n\n```javascript\nconst TodoStore = types\n    // 1\n    .model(\"TodoStore\", {\n        loaded: types.boolean, // 2\n        endpoint: \"http://localhost\", // 3\n        todos: types.array(Todo), // 4\n        selectedTodo: types.reference(Todo) // 5\n    })\n    .views(self => {\n        return {\n            // 6\n            get completedTodos() {\n                return self.todos.filter(t => t.done)\n            },\n            // 7\n            findTodosByUser(user) {\n                return self.todos.filter(t => t.assignee === user)\n            }\n        }\n    })\n    .actions(self => {\n        return {\n            addTodo(title) {\n                self.todos.push({\n                    id: Math.random(),\n                    title\n                })\n            }\n        }\n    })\n```\n\nWhen defining a model, it is advised to give the model a name for debugging purposes (see `// 1`).\nA model takes additionally object argument defining the properties.\n\nThe _properties_ argument is a key-value set where each key indicates the introduction of a property, and the value its type. The following types are acceptable:\n\n1.  A type. This can be a simple primitive type like `types.boolean`, see `// 2`, or a complex, possibly pre-defined type (`// 4`)\n2.  A primitive. Using a primitive as type is syntactic sugar for introducing a property with a default value. See `// 3`, `endpoint: \"http://localhost\"` is the same as `endpoint: types.optional(types.string, \"http://localhost\")`. The primitive type is inferred from the default value. Properties with a default value can be omitted in snapshots.\n3.  A [computed property](https://mobx.js.org/refguide/computed-decorator.html), see `// 6`. Computed properties are tracked and memoized by MobX. Computed properties will not be stored in snapshots or emit patch events. It is possible to provide a setter for a computed property as well. A setter should always invoke an action.\n4.  A view function (see `// 7`). A view function can, unlike computed properties, take arbitrary arguments. It won't be memoized, but its value can be tracked by MobX nonetheless. View functions are not allowed to change the model, but should rather be used to retrieve information from the model.\n\n_Tip: `(self) => ({ action1() { }, action2() { }})` is ES6 syntax for `function (self) { return { action1: function() { }, action2: function() { } }}`. In other words, it's short way of directly returning an object literal.\nFor that reason a comma between each member of a model is mandatory, unlike classes which are syntactically a totally different concept._\n\n`types.model` creates a chainable model type, where each chained method produces a new type:\n\n-   `.named(name)` clones the current type, but gives it a new name\n-   `.props(props)` produces a new type, based on the current one, and adds / overrides the specified properties\n-   `.actions(self => object literal with actions)` produces a new type, based on the current one, and adds / overrides the specified actions\n-   `.views(self => object literal with view functions)` produces a new type, based on the current one, and adds / overrides the specified view functions\n-   `.preProcessSnapshot(snapshot => snapshot)` can be used to pre-process the raw JSON before instantiating a new model. See [Lifecycle hooks](#lifecycle-hooks-for-typesmodel) or alternatively `types.snapshotProcessor`\n-   `.postProcessSnapshot(snapshot => snapshot)` can be used to post-process the raw JSON before getting a model snapshot. See [Lifecycle hooks](#lifecycle-hooks-for-typesmodel) or alternatively `types.snapshotProcessor`\n\nNote that `views` and `actions` don't define actions and views directly, but rather they should be given a function.\nThe function will be invoked when a new model instance is created. The instance will be passed in as the first and only argument typically called `self`.\nThis has two advantages:\n\n1.  All methods will always be bound correctly, and won't suffer from an unbound `this`\n2.  The closure can be used to store private state or methods of the instance. See also [actions](#actions) and [volatile state](#volatile-state).\n\nQuick example:\n\n```javascript\nconst TodoStore = types\n    .model(\"TodoStore\", {\n        /* props */\n    })\n    .actions(self => {\n        const instantiationTime = Date.now()\n\n        function addTodo(title) {\n            console.log(`Adding Todo ${title} after ${(Date.now() - instantiationTime) / 1000}s.`)\n            self.todos.push({\n                id: Math.random(),\n                title\n            })\n        }\n\n        return { addTodo }\n    })\n```\n\nIt is perfectly fine to chain multiple `views`, `props` calls etc in arbitrary order. This can be a great way to structure complex types, mix-in utility functions, etc. Each call in the chain creates a new, immutable type which can itself be stored and reused as part of other types, etc.\n\nIt is also possible to define lifecycle hooks in the _actions_ object. These are actions with a predefined name that are run at a specific moment. See [Lifecycle hooks](#lifecycle-hooks-for-typesmodel).\n\n### Tree semantics in detail\n\nMST trees have very specific semantics. These semantics purposefully constrain what you can do with MST. The reward for that is all kinds of generic features out of the box like snapshots, replayability, etc. If these constraints don't suit your app, you are probably better off using plain MobX with your own model classes, which is fine as well.\n\n1.  Each object in an MST tree is considered a _node_. Each primitive (and frozen) value is considered a _leaf_.\n1.  MST has only three types of nodes: _model_, _array_ and _map_.\n1.  Every _node_ tree in an MST tree is a tree in itself. Any operation that can be invoked on the complete tree can also be applied to a subtree.\n1.  A node can only exist exactly _once_ in a tree. This ensures it has a unique, identifiable position.\n1.  It is however possible to refer to another object in the _same_ tree by using _references_\n1.  There is no limit to the number of MST trees that live in an application. However, each node can only live in exactly one tree.\n1.  All _leaves_ in the tree must be serializable. It is not possible to store, for example, functions in a MST.\n1.  The only free-form type in MST is frozen, with the requirement that frozen values are immutable and serializable so that the MST semantics can still be upheld.\n1.  At any point in the tree it is possible to assign a snapshot to the tree instead of a concrete instance of the expected type. In that case an instance of the correct type, based on the snapshot, will be automatically created for you.\n1.  Nodes in the MST tree will be reconciled (the exact same instance will be reused) when updating the tree by any means, based on their _identifier_ property. If there is no identifier property, instances won't be reconciled.\n1.  If a node in the tree is replaced by another node, the original node will die and become unusable. This makes sure you are not accidentally holding on to stale objects anywhere in your application.\n1.  If you want to create a new node based on an existing node in a tree, you can either `detach` that node, or `clone` it.\n\nThese egghead.io lessons nicely leverage the specific semantics of MST trees:\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-build-forms-with-react-to-edit-mobx-state-tree-models\">egghead.io lesson 6: Build Forms with React to Edit mobx-state-tree Models</a></i><br>\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-remove-model-instances-from-the-tree\">egghead.io lesson 7: Remove Model Instances from the Tree</a></i><br>\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-create-an-entry-form-to-add-models-to-the-state-tree\">egghead.io lesson 8: Create an Entry Form to Add Models to the State Tree</a></i>\n\n### Composing trees\n\nIn MST every node in the tree is a tree in itself.\nTrees can be composed by composing their types:\n\n```javascript\nconst TodoStore = types.model({\n    todos: types.array(Todo)\n})\n\nconst storeInstance = TodoStore.create({\n    todos: [\n        {\n            title: \"Get biscuit\"\n        }\n    ]\n})\n```\n\nThe _snapshot_ passed to the `create` method of a type will recursively be turned in MST nodes. So, you can safely call:\n\n```javascript\nstoreInstance.todos[0].setTitle(\"Chocolate instead plz\")\n```\n\nBecause any node in a tree is a tree in itself, any built-in method in MST can be invoked on any node in the tree, not just the root.\nThis makes it possible to get a patch stream of a certain subtree, or to apply middleware to a certain subtree only.\n\n### Actions\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-attach-behavior-to-mobx-state-tree-models-using-actions\">egghead.io lesson 2: Attach Behavior to mobx-state-tree Models Using Actions</a></i>\n\nBy default, nodes can only be modified by one of their actions, or by actions higher up in the tree.\nActions can be defined by returning an object from the action initializer function that was passed to `actions`.\nThe initializer function is executed for each instance, so that `self` is always bound to the current instance.\nAlso, the closure of that function can be used to store so called _volatile_ state for the instance or to create private functions that can only\nbe invoked from the actions, but not from the outside.\n\n```javascript\nconst Todo = types\n    .model({\n        title: types.string\n    })\n    .actions(self => {\n        function setTitle(newTitle) {\n            self.title = newTitle\n        }\n\n        return {\n            setTitle\n        }\n    })\n```\n\nShorter form if no local state or private functions are involved:\n\n```javascript\nconst Todo = types\n    .model({\n        title: types.string\n    })\n    .actions(self => ({\n        // note the `({`, we are returning an object literal\n        setTitle(newTitle) {\n            self.title = newTitle\n        }\n    }))\n```\n\nActions are replayable and are therefore constrained in several ways:\n\n-   Trying to modify a node without using an action will throw an exception.\n-   It's recommended to make sure action arguments are serializable. Some arguments can be serialized automatically such as relative paths to other nodes\n-   Actions can only modify models that belong to the (sub)tree on which they are invoked\n-   You cannot use `this` inside actions. Instead, use `self`. This makes it safe to pass actions around without binding them or wrapping them in arrow functions.\n\nUseful methods:\n\n-   [`onAction`](docs/API/README.md#onaction) listens to any action that is invoked on the model or any of its descendants.\n-   [`addMiddleware`](docs/API/README.md#addmiddleware) adds an interceptor function to any action invoked on the subtree.\n-   [`applyAction`](docs/API/README.md#applyaction) invokes an action on the model according to the given action description\n\n#### Asynchronous actions\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-defining-asynchronous-processes-using-flow\">egghead.io lesson 12: Defining Asynchronous Processes Using Flow</a></i>\n\nAsynchronous actions have first class support in MST and are described in more detail [here](docs/async-actions.md#asynchronous-actions-and-middleware).\nAsynchronous actions are written by using generators and always return a promise. For a real working example see the [bookshop sources](https://github.com/mobxjs/mobx-state-tree/blob/adba1943af263898678fe148a80d3d2b9f8dbe63/examples/bookshop/src/stores/BookStore.js#L25). A quick example to get the gist:\n\n_Warning: don't import `flow` from `\"mobx\"`, but from `\"mobx-state-tree\"` instead!_\n\n```javascript\nimport { types, flow } from \"mobx-state-tree\"\n\nsomeModel.actions(self => {\n    const fetchProjects = flow(function*() {\n        // <- note the star, this a generator function!\n        self.state = \"pending\"\n        try {\n            // ... yield can be used in async/await style\n            self.githubProjects = yield fetchGithubProjectsSomehow()\n            self.state = \"done\"\n        } catch (error) {\n            // ... including try/catch error handling\n            console.error(\"Failed to fetch projects\", error)\n            self.state = \"error\"\n        }\n        // The action will return a promise that resolves to the returned value\n        // (or rejects with anything thrown from the action)\n        return self.githubProjects.length\n    })\n\n    return { fetchProjects }\n})\n```\n\nNote that, since MST v3.9, TypeScript correctly infers `flow` arguments and usually infers correctly `flow` return types,\nbut one exception to this case is when a `Promise` is returned as final value. In this case (and only in this case) this construct needs to be used:\n\n```ts\nreturn castFlowReturn(somePromise)\n```\n\n#### Action listeners versus middleware\n\nThe difference between action listeners and middleware is: middleware can intercept the action that is about to be invoked, modify arguments, return types, etc. Action listeners cannot intercept and are only notified. Action listeners receive the action arguments in a serializable format, while middleware receives the raw arguments. (`onAction` is actually just a built-in middleware).\n\nFor more details on creating middleware, see the [docs](docs/middleware.md).\n\n#### Disabling protected mode\n\nThis may be desired if the default protection of `mobx-state-tree` doesn't fit your use case. For example, if you are not interested in replayable actions or hate the effort of writing actions to modify any field, `unprotect(tree)` will disable the protected mode of a tree allowing anyone to directly modify the tree.\n\n### Views\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-derive-information-from-models-using-views\">egghead.io lesson 4: Derive Information from Models Using Views</a></i>\n\nAny fact that can be derived from your state is called a \"view\" or \"derivation\".\nSee the [Mobx concepts & principles](https://mobx.js.org/intro/concepts.html) for some background.\n\nViews come in two flavors: views with arguments and views without arguments. The latter are called computed values, based on the [computed](https://mobx.js.org/refguide/computed-decorator.html) concept in MobX. The main difference between the two is that computed properties create an explicit caching point, but later they work the same and any other computed value or MobX based reaction like [`@observer`](https://mobx.js.org/refguide/observer-component.html) components can react to them. Computed values are defined using _getter_ functions.\n\nExample:\n\n```javascript\nimport { autorun } from \"mobx\"\n\nconst UserStore = types\n    .model({\n        users: types.array(User)\n    })\n    .views(self => ({\n        get numberOfChildren() {\n            return self.users.filter(user => user.age < 18).length\n        },\n        numberOfPeopleOlderThan(age) {\n            return self.users.filter(user => user.age > age).length\n        }\n    }))\n\nconst userStore = UserStore.create(/* */)\n\n// Every time the userStore is updated in a relevant way, log messages will be printed\nautorun(() => {\n    console.log(\"There are now \", userStore.numberOfChildren, \" children\")\n})\nautorun(() => {\n    console.log(\"There are now \", userStore.numberOfPeopleOlderThan(75), \" pretty old people\")\n})\n```\n\nIf you want to share volatile state between views and actions, use `.extend` instead of `.views` + `.actions`. See the [volatile state](#volatile-state) section.\n\n### Snapshots\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-test-mobx-state-tree-models-by-recording-snapshots-or-patches\">egghead.io lesson 3: Test mobx-state-tree Models by Recording Snapshots or Patches</a></i><br>\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-store-store-in-local-storage\">egghead.io lesson 9: Store Store in Local Storage</a></i><br>\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-automatically-send-changes-to-the-server-by-using-onsnapshot\">egghead.io lesson 16: Automatically Send Changes to the Server by Using onSnapshot</a></i>\n\nSnapshots are the immutable serialization, in plain objects, of a tree at a specific point in time.\nSnapshots can be inspected through `getSnapshot(node, applyPostProcess)`.\nSnapshots don't contain any type information and are stripped from all actions, etc., so they are perfectly suitable for transportation.\nRequesting a snapshot is cheap as MST always maintains a snapshot of each node in the background and uses structural sharing.\n\n```javascript\ncoffeeTodo.setTitle(\"Tea instead plz\")\n\nconsole.dir(getSnapshot(coffeeTodo))\n// prints `{ title: \"Tea instead plz\" }`\n```\n\nSome interesting properties of snapshots:\n\n-   Snapshots are immutable\n-   Snapshots can be transported\n-   Snapshots can be used to update models or restore them to a particular state\n-   Snapshots are automatically converted to models when needed. So, the two following statements are equivalent: `store.todos.push(Todo.create({ title: \"test\" }))` and `store.todos.push({ title: \"test\" })`.\n\nUseful methods:\n\n-   `getSnapshot(model, applyPostProcess)`: returns a snapshot representing the current state of the model\n-   `onSnapshot(model, callback)`: creates a listener that fires whenever a new snapshot is available (but only one per MobX transaction).\n-   `applySnapshot(model, snapshot)`: updates the state of the model and all its descendants to the state represented by the snapshot\n\n## Patches\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-test-mobx-state-tree-models-by-recording-snapshots-or-patches\">egghead.io lesson 3: Test mobx-state-tree Models by Recording Snapshots or Patches</a></i>\n\nModifying a model does not only result in a new snapshot, but also in a stream of [JSON-patches](http://jsonpatch.com/) describing which modifications were made.\nPatches have the following signature:\n\n    export interface IJsonPatch {\n        op: \"replace\" | \"add\" | \"remove\"\n        path: string\n        value?: any\n    }\n\n-   Patches are constructed according to JSON-Patch, RFC 6902\n-   Patches are emitted immediately when a mutation is made and don't respect transaction boundaries (like snapshots)\n-   Patch listeners can be used to achieve deep observing\n-   The `path` attribute of a patch contains the path of the event relative to the place where the event listener is attached\n-   A single mutation can result in multiple patches, for example when splicing an array\n-   Patches can be reverse applied, which enables many powerful patterns like undo / redo\n\nUseful methods:\n\n-   `onPatch(model, listener)` attaches a patch listener to the provided model, which will be invoked whenever the model or any of its descendants is mutated\n-   `applyPatch(model, patch)` applies a patch (or array of patches) to the provided model\n\n### References and identifiers\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-create-relationships-in-your-data-with-mobx-state-tree-using-references-and-identifiers\">egghead.io lesson 13: Create Relationships in your Data with mobx-state-tree Using References and Identifiers</a></i>\n\nReferences and identifiers are a first-class concept in MST.\nThis makes it possible to declare references and keep the data normalized in the background, while you interact with it in a denormalized manner.\n\nExample:\n\n```javascript\nconst Todo = types.model({\n    id: types.identifier,\n    title: types.string\n})\n\nconst TodoStore = types.model({\n    todos: types.array(Todo),\n    selectedTodo: types.reference(Todo)\n})\n\n// create a store with a normalized snapshot\nconst storeInstance = TodoStore.create({\n    todos: [\n        {\n            id: \"47\",\n            title: \"Get coffee\"\n        }\n    ],\n    selectedTodo: \"47\"\n})\n\n// because `selectedTodo` is declared to be a reference, it returns the actual Todo node with the matching identifier\nconsole.log(storeInstance.selectedTodo.title)\n// prints \"Get coffee\"\n```\n\n#### Identifiers\n\n-   Each model can define zero or one `identifier()` properties\n-   The identifier property of an object cannot be modified after initialization\n-   Each identifier / type combination should be unique within the entire tree\n-   Identifiers are used to reconcile items inside arrays and maps - wherever possible - when applying snapshots\n-   The `map.put()` method can be used to simplify adding objects that have identifiers to [maps](docs/API/README.md#typesmap)\n-   The primary goal of identifiers is not validation, but reconciliation and reference resolving. For this reason identifiers cannot be defined or updated after creation. If you want to check if some value just looks as an identifier, without providing the above semantics; use something like: `types.refinement(types.string, v => v.match(/someregex/))`\n\n_Tip: If you know the format of the identifiers in your application, leverage `types.refinement` to actively check this, for example the following definition enforces that identifiers of `Car` always start with the string `\"Car_\"`:\n\n```javascript\nconst Car = types.model(\"Car\", {\n    id: types.refinement(types.identifier, identifier => identifier.indexOf(\"Car_\") === 0)\n})\n```\n\n#### References\n\nReferences are defined by mentioning the type they should resolve to. The targeted type should have exactly one attribute of the type `identifier`.\nReferences are looked up through the entire tree but per type, so identifiers need to be unique in the entire tree.\n\n#### Customizable references\n\nThe default implementation uses the `identifier` cache to resolve references (See [`resolveIdentifier`](docs/API/README.md#resolveIdentifier)).\nHowever, it is also possible to override the resolve logic and provide your own custom resolve logic.\nThis also makes it possible to, for example, trigger a data fetch when trying to resolve the reference ([example](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mobx-state-tree/__tests__/core/reference-custom.test.ts#L148)).\n\nExample:\n\n```javascript\nconst User = types.model({\n    id: types.identifier,\n    name: types.string\n})\n\nconst UserByNameReference = types.maybeNull(\n    types.reference(User, {\n        // given an identifier, find the user\n        get(identifier /* string */, parent: any /*Store*/) {\n            return parent.users.find(u => u.name === identifier) || null\n        },\n        // given a user, produce the identifier that should be stored\n        set(value /* User */) {\n            return value.name\n        }\n    })\n)\n\nconst Store = types.model({\n    users: types.array(User),\n    selection: UserByNameReference\n})\n\nconst s = Store.create({\n    users: [{ id: \"1\", name: \"Michel\" }, { id: \"2\", name: \"Mattia\" }],\n    selection: \"Mattia\"\n})\n```\n\n#### Reference validation: `isValidReference`, `tryReference`, `onInvalidated` hook and `types.safeReference`\n\nAccessing an invalid reference (a reference to a dead/detached node) triggers an exception.\n\nIn order to check if a reference is valid, MST offers the `isValidReference(() => ref): boolean` function:\n\n```ts\nconst isValid = isValidReference(() => store.myRef)\n```\n\nAlso, if you are unsure if a reference is valid or not you can use the `tryReference(() => ref): ref | undefined` function:\n\n```ts\n// the result will be the passed ref if ok, or undefined if invalid\nconst maybeValidRef = tryReference(() => store.myRef)\n```\n\nThe options parameter for references also accepts an optional `onInvalidated` hook, which will be called when the reference target node that the reference is pointing to is about to be detached/destroyed. It has the following signature:\n\n```ts\nconst refWithOnInvalidated = types.reference(Todo, {\n    onInvalidated(event: {\n        // what is causing the target to become invalidated\n        cause: \"detach\" | \"destroy\" | \"invalidSnapshotReference\"\n        // the target that is about to become invalidated (undefined if \"invalidSnapshotReference\")\n        invalidTarget: STN | undefined\n        // the identifier that is about to become invalidated\n        invalidId: string | number\n        // parent node of the reference (not the reference target)\n        parent: IAnyStateTreeNode\n        // a function to remove the reference from its parent (or set to undefined in the case of models)\n        removeRef: () => void\n        // a function to set our reference to a new target\n        replaceRef: (newRef: STN | null | undefined) => void\n    }) {\n        // do something\n    }\n})\n```\n\nNote that invalidation will only trigger while the reference is attached to a parent (be it a model, an array, a map, etc.).\n\nA default implementation of such `onInvalidated` hook is provided by the `types.safeReference` type. It is like a standard reference, except that once the target node becomes invalidated it will:\n\n-   If its parent is a model: Set its own property to `undefined`\n-   If its parent is an array: Remove itself from the array\n-   If its parent is a map: Remove itself from the map\n\nIn addition to the options possible for a plain reference type, the optional options parameter object also accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable for model properties.\nWhen used inside collections (arrays/maps) it is recommended to set this option to false so it can't take undefined as value, which is usually the desired in those cases.\n\nStrictly speaking, `safeReference` with `acceptsUndefined` set to true (the default) is implemented as\n\n```js\ntypes.maybe(\n    types.reference(Type, {\n        ...customGetSetIfAvailable,\n        onInvalidated(ev) {\n            ev.removeRef()\n        }\n    })\n)\n```\n\nand with `acceptsUndefined` set to false as\n\n```js\ntypes.reference(Type, {\n    ...customGetSetIfAvailable,\n    onInvalidated(ev) {\n        ev.removeRef()\n    }\n})\n```\n\n```js\nconst Todo = types.model({ id: types.identifier })\nconst Store = types.model({\n    todos: types.array(Todo),\n    selectedTodo: types.safeReference(Todo),\n    multipleSelectedTodos: types.array(types.safeReference(Todo, { acceptsUndefined: false }))\n})\n\n// given selectedTodo points to a valid Todo and that Todo is later removed from the todos\n// array, then selectedTodo will automatically become undefined, and if it is included in multipleSelectedTodos\n// then it will be removed from the array\n```\n\n### Listening to observables, snapshots, patches or actions\n\nMST is powered by MobX. This means that it is immediately compatible with `observer` components or reactions like `autorun`:\n\n```javascript\nimport { autorun } from \"mobx\"\n\nautorun(() => {\n    console.log(storeInstance.selectedTodo.title)\n})\n```\n\nBecause MST keeps immutable snapshots in the background, it is also possible to be notified when a new snapshot of the tree is available. This is similar to `.subscribe` on a redux store:\n\n```javascript\nonSnapshot(storeInstance, newSnapshot => {\n    console.dir(\"Got new state: \", newSnapshot)\n})\n```\n\nHowever, sometimes it is more useful to precisely know what has changed rather than just receiving a complete new snapshot.\nFor that, MST supports json-patches out of the box.\n\n```javascript\nonPatch(storeInstance, patch => {\n    console.dir(\"Got change: \", patch)\n})\n\nstoreInstance.todos[0].setTitle(\"Add milk\")\n// prints:\n{\n    path: \"/todos/0\",\n    op: \"replace\",\n    value: \"Add milk\"\n}\n```\n\nSimilarly, you can be notified whenever an action is invoked by using `onAction`.\n\n```javascript\nonAction(storeInstance, call => {\n    console.dir(\"Action was called: \", call)\n})\n\nstoreInstance.todos[0].setTitle(\"Add milk\")\n// prints:\n{\n    path: \"/todos/0\",\n    name: \"setTitle\",\n    args: [\"Add milk\"]\n}\n```\n\nIt is even possible to intercept actions before they are applied by adding middleware using `addMiddleware`:\n\n```javascript\naddMiddleware(storeInstance, (call, next) => {\n    call.args[0] = call.args[0].replace(/tea/gi, \"Coffee\")\n    return next(call)\n})\n```\n\nA more extensive middleware example can be found in this [code sandbox](https://codesandbox.io/s/mQrqy8j73).\nFor more details on creating middleware and the exact specification of middleware events, see the [docs](docs/middleware.md).\n\nFinally, it is not only possible to be notified about snapshots, patches or actions. It is also possible to re-apply them by using `applySnapshot`, `applyPatch` or `applyAction`!\n\n## Volatile state\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-use-volatile-state-and-lifecycle-methods-to-manage-private-state\">egghead.io lesson 15: Use Volatile State and Lifecycle Methods to Manage Private State</a></i>\n\nMST models primarily aid in storing _persistable_ state. State that can be persisted, serialized, transferred, patched, replaced, etc.\nHowever, sometimes you need to keep track of temporary, non-persistable state. This is called _volatile_ state in MST. Examples include promises, sockets, DOM elements, etc. - state which is needed for local purposes as long as the object is alive.\n\nVolatile state (which is also private) can be introduced by creating variables inside any of the action initializer functions.\n\nVolatile is preserved for the life-time of an object and not reset when snapshots are applied, etc. Note that the life time of an object depends on proper reconciliation, see the [how does reconciliation work?](#how-does-reconciliation-work) section below.\n\nThe following is an example of an object with volatile state. Note that volatile state here is used to track a XHR request and clean up resources when it is disposed. Without volatile state this kind of information would need to be stored in an external WeakMap or something similar.\n\n```javascript\nconst Store = types\n    .model({\n        todos: types.array(Todo),\n        state: types.enumeration(\"State\", [\"loading\", \"loaded\", \"error\"])\n    })\n    .actions(self => {\n        let pendingRequest = null // a Promise\n\n        function afterCreate() {\n            self.state = \"loading\"\n            pendingRequest = someXhrLib.createRequest(\"someEndpoint\")\n        }\n\n        function beforeDestroy() {\n            // abort the request, no longer interested\n            pendingRequest.abort()\n        }\n\n        return {\n            afterCreate,\n            beforeDestroy\n        }\n    })\n```\n\nSome tips:\n\n1.  Note that multiple `actions` calls can be chained. This makes it possible to create multiple closures with their own protected volatile state.\n2.  Although in the above example the `pendingRequest` could be initialized directly in the action initializer, it is recommended to do this in the `afterCreate` hook, which will only once the entire instance has been set up (there might be many action and property initializers for a single type).\n\n3.  The above example doesn't actually use the promise. For how to work with promises / asynchronous flows, see the [asynchronous actions](#asynchronous-actions) section above.\n\n4.  It is possible to share volatile state between views and actions by using `extend`. `.extend` works like a combination of `.actions` and `.views` and should return an object with a `actions` and `views` field:\n\nHere's an example of how to do your own volatile state using an observable:\n\n```javascript\n// if your local state is part of a view getter (computed) then\n// it is important to make sure that state used such getters are observable,\n// or else the value returned by the view would become stale upon observation\nconst Todo = types.model({}).extend(self => {\n    const localState = observable.box(3)\n\n    return {\n        views: {\n            // note this one IS a getter (computed value)\n            get x() {\n                return localState.get()\n            }\n        },\n        actions: {\n            setX(value) {\n                localState.set(value)\n            }\n        }\n    }\n})\n```\n\nAnd here's an example of how to do your own volatile state _not_ using an observable (but if you do this make sure the local state will _never_ be used in a computed value first and bear in mind it _won't_ be reactive!):\n\n```javascript\n// if not using an observable then make sure your local state is NOT part of a view getter or computed value of any kind!\n// also changes to it WON'T be reactive\nconst Todo = types.model({}).extend(self => {\n    let localState = 3\n\n    return {\n        views: {\n            // note this one is NOT a getter (NOT a computed value)\n            // if this were a getter this value would get stale upon observation\n            getX() {\n                return localState\n            }\n        },\n        actions: {\n            setX(value) {\n                localState = value\n            }\n        }\n    }\n})\n```\n\n### model.volatile\n\nSince the pattern above (having a volatile state that is _observable_ (in terms of Mobx observables) and _readable_ from outside the instance) is such a common pattern there is a shorthand to declare such properties. The example above can be rewritten as:\n\n```javascript\nconst Todo = types\n    .model({})\n    .volatile(self => ({\n        localState: 3\n    }))\n    .actions(self => ({\n        setX(value) {\n            self.localState = value\n        }\n    }))\n```\n\nThe object that is returned from the `volatile` initializer function can contain any piece of data and will result in an instance property with the same name. Volatile properties have the following characteristics:\n\n1.  The can be read from outside the model (if you want hidden volatile state, keep the state in your closure as shown in the previous section, and _only_ if it is not used on a view consider not making it observable)\n2.  The volatile properties will be only observable, see [observable _references_](https://mobx.js.org/refguide/modifiers.html). Values assigned to them will be unmodified and not automatically converted to deep observable structures.\n3.  Like normal properties, they can only be modified through actions\n4.  Volatile props will not show up in snapshots, and cannot be updated by applying snapshots\n5.  Volatile props are preserved during the lifecycle of an instance. See also [reconciliation](#reconciliation)\n6.  Changes in volatile props won't show up in the patch or snapshot stream\n7.  It is currently not supported to define getters / setters in the object returned by `volatile`\n\n## Dependency injection\n\nWhen creating a new state tree it is possible to pass in environment specific data by passing an object as the second argument to a `.create` call.\nThis object should be (shallowly) immutable and can be accessed by any model in the tree by calling `getEnv(self)`.\n\nThis is useful to inject environment or test-specific utilities like a transport layer, loggers, etc. This is also very useful to mock behavior in unit tests or provide instantiated utilities to models without requiring singleton modules.\nSee also the [bookshop example](https://github.com/mobxjs/mobx-state-tree/blob/a4f25de0c88acf0e239acb85e690e91147a8f0f0/examples/bookshop/src/stores/ShopStore.test.js#L9) for inspiration.\n\n```javascript\nimport { types, getEnv } from \"mobx-state-tree\"\n\nconst Todo = types\n    .model({\n        title: \"\"\n    })\n    .actions(self => ({\n        setTitle(newTitle) {\n            // grab injected logger and log\n            getEnv(self).logger.log(\"Changed title to: \" + newTitle)\n            self.title = newTitle\n        }\n    }))\n\nconst Store = types.model({\n    todos: types.array(Todo)\n})\n\n// setup logger and inject it when the store is created\nconst logger = {\n    log(msg) {\n        console.log(msg)\n    }\n}\n\nconst store = Store.create(\n    {\n        todos: [{ title: \"Grab tea\" }]\n    },\n    {\n        logger: logger // inject logger to the tree\n    }\n)\n\nstore.todos[0].setTitle(\"Grab coffee\")\n// prints: Changed title to: Grab coffee\n```\n\n# Types overview\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-more-mobx-state-tree-types-map-literal-union-and-enumeration\">egghead.io lesson 11: More mobx-state-tree Types: map, literal, union, and enumeration</a></i><br>\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-create-dynamic-types-and-use-type-composition-to-extract-common-functionality\">egghead.io lesson 17: Create Dynamic Types and use Type Composition to Extract Common Functionality</a></i>\n\nThese are the types available in MST. All types can be found in the `types` namespace, e.g. `types.string`. See [Api Docs](docs/API/README.md) for examples.\n\n## Complex types\n\n-   `types.model(properties, actions)` Defines a \"class like\" type with properties and actions to operate on the object.\n-   `types.array(type)` Declares an array of the specified type.\n-   `types.map(type)` Declares a map of the specified type.\n\nNote that since MST v3 `types.array` and `types.map` are wrapped in `types.optional` by default, with `[]` and `{}` set as their default values, respectively.\n\n## Primitive types\n\n-   `types.string`\n-   `types.number`\n-   `types.integer`\n-   `types.boolean`\n-   `types.Date`\n-   `types.custom` creates a custom primitive type. This is useful to define your own types that map a serialized form one-to-one to an immutable object like a Decimal or Date.\n\n## Utility types\n\n-   `types.union(options?: { dispatcher?: (snapshot) => Type, eager?: boolean }, types...)` create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function to determine the type. When `eager` flag is set to `true` (default) - the first matching type will be used, if set to `false` the type check will pass only if exactly 1 type matches.\n-   `types.optional(type, defaultValue, optionalValues?)` marks an value as being optional (in e.g. a model). If a value is not provided/`undefined` (or set to any of the primitive values passed as an optional `optionalValues` array) the `defaultValue` will be used instead. If `defaultValue` is a function, it will be evaluated. This can be used to generate, for example, IDs or timestamps upon creation.\n-   `types.literal(value)` can be used to create a literal type, where the only possible value is specifically that value. This is very powerful in combination with `union`s. E.g. `temperature: types.union(types.literal(\"hot\"), types.literal(\"cold\"))`.\n-   `types.enumeration(name?, options: string[])` creates an enumeration. This method is a shorthand for a union of string literals. If you are using typescript and want to create a type based on an string enum (e.g. `enum Color { ... }`) then use `types.enumeration<Color>(\"Color\", Object.values(Color))`, where the `\"Color\"` name argument is optional.\n-   `types.refinement(name?, baseType, (snapshot) => boolean)` creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n-   `types.maybe(type)` makes a type optional and nullable, shorthand for `types.optional(types.union(type, types.literal(undefined)), undefined)`.\n-   `types.maybeNull(type)` like `maybe`, but uses `null` to represent the absence of a value.\n-   `types.null` the type of `null`.\n-   `types.undefined` the type of `undefined`.\n-   `types.late(() => type)` can be used to create recursive or circular types, or types that are spread over files in such a way that circular dependencies between files would be an issue otherwise.\n-   `types.frozen(subType? | defaultValue?)` Accepts any kind of serializable value (both primitive and complex), but assumes that the value itself is **immutable** and **serializable**.\n    `frozen` can be invoked in a few different ways:\n    -   `types.frozen()` - behaves the same as types.frozen in MST 2.\n    -   `types.frozen(subType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type. Note that the type will not actually be instantiated, so it can only be used to check the shape of the data. Adding views or actions to SubType would be pointless.\n    -   `types.frozen(someDefaultValue)` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field\n    -   (Typescript) `types.frozen<TypeScriptType>(...)` - provide a typescript type, to help in strongly typing the field (design time only)\n-   `types.compose(name?, type1...typeX)`, creates a new model type by taking a bunch of existing types and combining them into a new one.\n-   `types.reference(targetType)` creates a property that is a reference to another item of the given `targetType` somewhere in the same tree. See [references](#references) for more details.\n-   `types.safeReference(targetType)` is like a standard reference, except that it accepts the undefined value by default and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps when the reference it is pointing to gets detached/destroyed. See [references](#references) for more details.\n-   `types.snapshotProcessor(type, processors, name?)` runs a pre snapshot / post snapshot processor before/after serializing a given type. Example:\n    ```ts\n    const Todo1 = types.model({ text: types.string })\n    // in the backend the text type must be null when empty\n    interface BackendTodo {\n        text: string | null\n    }\n    const Todo2 = types.snapshotProcessor(Todo1, {\n        // from snapshot to instance\n        preProcessor(sn: BackendTodo) {\n            return {\n                text: sn.text || \"\";\n            }\n        },\n        // from instance to snapshot\n        postProcessor(sn): BackendTodo {\n            return {\n                text: !sn.text ? null : sn.text\n            }\n        }\n    })\n    ```\n\n## Property types\n\nProperty types can only be used as a direct member of a `types.model` type and not further composed (for now).\n\n-   `types.identifier` Only one such member can exist in a `types.model` and should uniquely identify the object. See [identifiers](#identifiers) for more details. `subType` should be either `types.string` or `types.number`, defaulting to the first if not specified.\n-   `types.identifierNumber` Similar to `types.identifier`. However, during serialization, the identifier value will be parsed from / serialized to a number.\n\n## LifeCycle hooks for `types.model`\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-loading-data-from-the-server\">egghead.io lesson 14: Loading Data from the Server after model creation</a></i>\n\nAll of the below hooks can be created by returning an action with the given name, like:\n\n```javascript\nconst Todo = types.model(\"Todo\", { done: true }).actions(self => ({\n    afterCreate() {\n        console.log(\"Created a new todo!\")\n    }\n}))\n```\n\nThe exception to this rule are the `preProcessSnapshot` and `postProcessSnapshot` hooks (see `types.snapshotProcessor` as an alternative):\n\n```javascript\ntypes\n    .model(\"Todo\", { done: true })\n    .preProcessSnapshot(snapshot => ({\n        // auto convert strings to booleans as part of preprocessing\n        done: snapshot.done === \"true\" ? true : snapshot.done === \"false\" ? false : snapshot.done\n    }))\n    .actions(self => ({\n        afterCreate() {\n            console.log(\"Created a new todo!\")\n        }\n    }))\n```\n\nNote: pre and post processing are just meant to convert your data into types that are more acceptable to MST. Typically it should be the case that `postProcess(preProcess(snapshot)) === snapshot. If that isn't the case, consider whether you shouldn't be using a dedicated a view instead to normalize your snapshot to some other format you need.\n\n| Hook                  | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `afterCreate`         | Immediately after an instance is created and initial values are applied. Children will fire this event before parents. You can't make assumptions about the parent safely, use `afterAttach` if you need to.                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| `afterAttach`         | As soon as the _direct_ parent is assigned (this node is attached to another node). If an element is created as part of a parent, `afterAttach` is also fired. Unlike `afterCreate`, `afterAttach` will fire breadth first. So, in `afterAttach` one can safely make assumptions about the parent, but in `afterCreate` not                                                                                                                                                                                                                                                                                                                   |\n| `beforeDetach`        | As soon as the node is removed from the _direct_ parent, but only if the node is _not_ destroyed. In other words, when `detach(node)` is used                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| `beforeDestroy`       | Called before the node is destroyed, as a result of calling `destroy`, or by removing or replacing the node from the tree. Child destructors will fire before parents                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| `preProcessSnapshot`  | Before creating an instance or applying a snapshot to an existing instance, this hook is called to give the option to transform the snapshot before it is applied. The hook should be a _pure_ function that returns a new snapshot. This can be useful to do some data conversion, enrichment, property renames, etc. This hook is not called for individual property updates. _\\*\\*Note 1: Unlike the other hooks, this one is \\_not_ created as part of the `actions` initializer, but directly on the type!**\\_ \\_**Note 2: The `preProcessSnapshot` transformation must be pure; it should not modify its original input argument!\\*\\*\\_ |\n| `postProcessSnapshot` | This hook is called every time a new snapshot is being generated. Typically it is the inverse function of `preProcessSnapshot`. This function should be a pure function that returns a new snapshot. _\\*\\*Note: Unlike the other hooks, this one is \\_not_ created as part of the `actions` initializer, but directly on the type!\\*\\*\\_                                                                                                                                                                                                                                                                                                      |\n\nNote, except for `preProcessSnapshot` and `postProcessSnapshot`, all hooks should be defined as actions.\n\nAll hooks can be defined multiple times and can be composed automatically.\n\n# Api overview\n\nSee the [full API docs](docs/API/README.md) for more details.\n\n| signature                                                                                                             |                                                                                                                                                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [`addDisposer(node, () => void)`](docs/API/README.md#adddisposer)                                                     | Add a function to be invoked whenever the target node is about to be destroyed                                                                                                                                                                        |\n| [`addMiddleware(node, middleware: (actionDescription, next) => any, includeHooks)`](docs/API/README.md#addmiddleware) | Attaches middleware to a node. See [middleware](docs/middleware.md). Returns disposer.                                                                                                                                                                |\n| [`applyAction(node, actionDescription)`](docs/API/README.md#applyaction)                                              | Replays an action on the targeted node                                                                                                                                                                                                                |\n| [`applyPatch(node, jsonPatch)`](docs/API/README.md#applypatch)                                                        | Applies a JSON patch, or array of patches, to a node in the tree                                                                                                                                                                                      |\n| [`applySnapshot(node, snapshot)`](docs/API/README.md#applysnapshot)                                                   | Updates a node with the given snapshot                                                                                                                                                                                                                |\n| [`cast(nodeOrSnapshot)`](docs/API/README.md#cast)                                                                     | Cast a node instance or snapshot to a node instance so it can be used in assignment operations                                                                                                                                                        |\n| [`castToSnapshot(nodeOrSnapshot)`](docs/API/README.md#casttosnapshot)                                                 | Cast a node instance to a snapshot so it can be used inside create operations                                                                                                                                                                         |\n| [`castToReferenceSnapshot(node)`](docs/API/README.md#casttoreferencesnapshot)                                         | Cast a node instance to a reference snapshot so it can be used inside create operations                                                                                                                                                               |\n| [`createActionTrackingMiddleware`](docs/API/README.md#createactiontrackingmiddleware)                                 | Utility to make writing middleware that tracks async actions less cumbersome. Consider migrating to `createActionTrackingMiddleware2`                                                                                                                 |\n| [`createActionTrackingMiddleware2`](docs/API/README.md#createactiontrackingmiddleware)                                | Utility to make writing middleware that tracks async actions less cumbersome                                                                                                                                                                          |\n| [`clone(node, keepEnvironment?: true \\| false \\| newEnvironment)`](docs/API/README.md#clone)                          | Creates a full clone of the given node. By default preserves the same environment                                                                                                                                                                     |\n| [`decorate(handler, function)`](docs/API/README.md#decorate)                                                          | Attaches middleware to a specific action (or flow)                                                                                                                                                                                                    |\n| [`destroy(node)`](docs/API/README.md#destroy)                                                                         | Kills `node`, making it unusable. Removes it from any parent in the process                                                                                                                                                                           |\n| [`detach(node)`](docs/API/README.md#detach)                                                                           | Removes `node` from its current parent, and lets it live on as standalone tree                                                                                                                                                                        |\n| [`flow(generator)`](docs/API/README.md#flow)                                                                          | Creates an asynchronous flow based on a generator function                                                                                                                                                                                            |\n| [`castFlowReturn(value)`](docs/API/README.md#castflowreturn)                                                          | Casts a flow return value so it can be correctly inferred as return type. Only needed when using TypeScript and when returning a Promise.                                                                                                             |\n| [`getChildType(node, property?)`](docs/API/README.md#getchildtype)                                                    | Returns the declared type of the given `property` of `node`. For arrays and maps `property` can be omitted as they all have the same type                                                                                                             |\n| [`getEnv(node)`](docs/API/README.md#getenv)                                                                           | Returns the environment of `node`, see [environments](#environments)                                                                                                                                                                                  |\n| [`getParent(node, depth=1)`](docs/API/README.md#getparent)                                                            | Returns the intermediate parent of the `node`, or a higher one if `depth > 1`                                                                                                                                                                         |\n| [`getParentOfType(node, type)`](docs/API/README.md#getparentoftype)                                                   | Return the first parent that satisfies the provided type                                                                                                                                                                                              |\n| [`getPath(node)`](docs/API/README.md#getpath)                                                                         | Returns the path of `node` in the tree                                                                                                                                                                                                                |\n| [`getPathParts(node)`](docs/API/README.md#getpathparts)                                                               | Returns the path of `node` in the tree, unescaped as separate parts                                                                                                                                                                                   |\n| [`getRelativePath(base, target)`](docs/API/README.md#getrelativepath)                                                 | Returns the short path, which one could use to walk from node `base` to node `target`, assuming they are in the same tree. Up is represented as `../`                                                                                                 |\n| [`getRoot(node)`](docs/API/README.md#getroot)                                                                         | Returns the root element of the tree containing `node`                                                                                                                                                                                                |\n| [`getIdentifier(node)`](docs/API/README.md#getidentifier)                                                             | Returns the identifier of the given element                                                                                                                                                                                                           |\n| [`getNodeId(node)`](docs/API/README.md#getnodeid)                                                                     | Returns the unique node id (not to be confused with the instance identifier) for a given instance                                                                                                                                                     |\n| [`getSnapshot(node, applyPostProcess)`](docs/API/README.md#getsnapshot)                                               | Returns the snapshot of the `node`. See [snapshots](#snapshots)                                                                                                                                                                                       |\n| [`getType(node)`](docs/API/README.md#gettype)                                                                         | Returns the type of `node`                                                                                                                                                                                                                            |\n| [`hasParent(node, depth=1)`](docs/API/README.md#hasparent)                                                            | Returns `true` if `node` has a parent at `depth`                                                                                                                                                                                                      |\n| [`hasParentOfType(node, type)`](docs/API/README.md#hasparentoftype)                                                   | Returns `true` if the `node` has a parent that satisfies the provided type                                                                                                                                                                            |\n| [`isAlive(node)`](docs/API/README.md#isalive)                                                                         | Returns `true` if `node` is alive                                                                                                                                                                                                                     |\n| [`isStateTreeNode(value)`](docs/API/README.md#isstatetreenode)                                                        | Returns `true` if `value` is a node of a mobx-state-tree                                                                                                                                                                                              |\n| [`isProtected(value)`](docs/API/README.md#isprotected)                                                                | Returns `true` if the given node is protected, see [actions](#actions)                                                                                                                                                                                |\n| [`isValidReference(() => node \\| null \\| undefined, checkIfAlive = true)`](docs/API/README.md#isvalidreference)       | Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.                                                                                                                          |\n| [`isRoot(node)`](docs/API/README.md#isroot)                                                                           | Returns true if `node` has no parents                                                                                                                                                                                                                 |\n| [`joinJsonPath(parts)`](docs/API/README.md#joinjsonpath)                                                              | Joins and escapes the given path `parts` into a JSON path                                                                                                                                                                                             |\n| [`onAction(node, (actionDescription) => void)`](docs/API/README.md#onaction)                                          | A built-in middleware that calls the provided callback with an action description upon each invocation. Returns disposer                                                                                                                              |\n| [`onPatch(node, (patch) => void)`](docs/API/README.md#onpatch)                                                        | Attach a JSONPatch listener, that is invoked for each change in the tree. Returns disposer                                                                                                                                                            |\n| [`onSnapshot(node, (snapshot) => void)`](docs/API/README.md#onsnapshot)                                               | Attach a snapshot listener, that is invoked for each change in the tree. Returns disposer                                                                                                                                                             |\n| [`process(generator)`](docs/API/README.md#process)                                                                    | `DEPRECATED`  replaced with [flow](docs/API/README.md#flow)                                                                                                                                                                                          |\n| [`protect(node)`](docs/API/README.md#protect)                                                                         | Protects an unprotected tree against modifications from outside actions                                                                                                                                                                               |\n| [`recordActions(node)`](docs/API/README.md#recordactions)                                                             | Creates a recorder that listens to all actions in `node`. Call `.stop()` on the recorder to stop this, and `.replay(target)` to replay the recorded actions on another tree                                                                           |\n| [`recordPatches(node)`](docs/API/README.md#recordpatches)                                                             | Creates a recorder that listens to all patches emitted by the node. Call `.stop()` on the recorder to stop this, and `.replay(target)` to replay the recorded patches on another tree                                                                 |\n| [`getMembers(node)`](docs/API/README.md#getMembers)                                                                   | Returns the model name, properties, actions, views, volatiles of a model node instance                                                                                                                                                                |\n| [`getPropertyMembers(typeOrNode)`](docs/API/README.md#getPropertyMembers)                                             | Returns the model name and properties of a model type for either a model type or a model node                                                                                                                                                         |\n| [`resolve(node, path)`](docs/API/README.md#resolve)                                                                   | Resolves a `path` (json path) relatively to the given `node`                                                                                                                                                                                          |\n| [`resolveIdentifier(type, target, identifier)`](docs/API/README.md#resolveidentifier)                                 | resolves an identifier of a given type in a model tree                                                                                                                                                                                                |\n| [`resolvePath(target, path)`](docs/API/README.md#resolvepath)                                                         | resolves a JSON path, starting at the specified target                                                                                                                                                                                                |\n| [`setLivelinessChecking(\"warn\" \\| \"ignore\" \\| \"error\")`](docs/API/README.md#setlivelinesschecking)                    | Defines what MST should do when running into reads / writes to objects that have died. By default it will print a warning. Use te `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place |\n| [`getLivelinessChecking()`](docs/API/README.md#getlivelinesschecking)                                                 | Returns the current liveliness checking mode.                                                                                                                                                                                                         |\n| [`splitJsonPath(path)`](docs/API/README.md#splitjsonpath)                                                             | Splits and unescapes the given JSON `path` into path parts                                                                                                                                                                                            |\n| [`typecheck(type, value)`](docs/API/README.md#typecheck)                                                              | Typechecks a value against a type. Throws on errors. Use this if you need typechecks even in a production build.\nNOTE: set process.env.ENABLE_TYPE_CHECK = \"true\" if you want to enable typeChecking in any environment                                                                                                                                      |\n| [`tryResolve(node, path)`](docs/API/README.md#tryresolve)                                                             | Like `resolve`, but just returns `null` if resolving fails at any point in the path                                                                                                                                                                   |\n| [`tryReference(() => node \\| null \\| undefined, checkIfAlive = true)`](docs/API/README.md#tryreference)                 | Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if it the check passes, else it returns undefined.                                                                                    |\n| [`unprotect(node)`](docs/API/README.md#unprotect)                                                                     | Unprotects `node`, making it possible to directly modify any value in the subtree, without actions                                                                                                                                                    |\n| [`walk(startNode, (node) => void)`](docs/API/README.md#walk)                                                          | Performs a depth-first walk through a tree                                                                                                                                                                                                            |\n| [`escapeJsonPath(path)`](docs/API/README.md#escapejsonpath)                                                           | escape special characters in an identifier, according to http://tools.ietf.org/html/rfc6901                                                                                                                                                           |\n| [`unescapeJsonPath(path)`](docs/API/README.md#unescapejsonpath)                                                       | escape special characters in an identifier, according to http://tools.ietf.org/html/rfc6901                                                                                                                                                           |\n| [`isType(value)`](docs/API/README.md#isType)                                                                          | Returns if a given value represents a type.                                                                                                                                                                                                           |\n| [`isArrayType(value)`](docs/API/README.md#isArrayType)                                                                | Returns if a given value represents an array type.                                                                                                                                                                                                    |\n| [`isFrozenType(value)`](docs/API/README.md#isFrozenType)                                                              | Returns if a given value represents a frozen type.                                                                                                                                                                                                    |\n| [`isIdentifierType(value)`](docs/API/README.md#isIdentifierType)                                                      | Returns if a given value represents an identifier type.                                                                                                                                                                                               |\n| [`isLateType(value)`](docs/API/README.md#isLateType)                                                                  | Returns if a given value represents a late type.                                                                                                                                                                                                      |\n| [`isLiteralType(value)`](docs/API/README.md#isLiteralType)                                                            | Returns if a given value represents a literal type.                                                                                                                                                                                                   |\n| [`isMapType(value)`](docs/API/README.md#isMapType)                                                                    | Returns if a given value represents a map type.                                                                                                                                                                                                       |\n| [`isModelType(value)`](docs/API/README.md#isModelType)                                                                | Returns if a given value represents a model type.                                                                                                                                                                                                     |\n| [`isOptionalType(value)`](docs/API/README.md#isOptionalType)                                                          | Returns if a given value represents an optional type.                                                                                                                                                                                                 |\n| [`isPrimitiveType(value)`](docs/API/README.md#isPrimitiveType)                                                        | Returns if a given value represents a primitive type.                                                                                                                                                                                                 |\n| [`isReferenceType(value)`](docs/API/README.md#isReferenceType)                                                        | Returns if a given value represents a reference type.                                                                                                                                                                                                 |\n| [`isRefinementType(value)`](docs/API/README.md#isRefinementType)                                                      | Returns if a given value represents a refinement type.                                                                                                                                                                                                |\n| [`isUnionType(value)`](docs/API/README.md#isUnionType)                                                                | Returns if a given value represents a union type.                                                                                                                                                                                                     |\n| [`getRunningActionContext()`](docs/API/README.md#getrunningactioncontext)                                             | Returns the currently executing MST action context, or undefined if none.                                                                                                                                                                             |\n| [`isActionContextChildOf(actionContext, parent)`](docs/API/README.md#isActionContextChildOf)                          | Returns if the given action context is a parent of this action context.                                                                                                                                                                               |\n| [`isActionContextThisOrChildOf(actionContext, parentOrSame)`](docs/API/README.md#isActionContextThisOrChildOf)        | Returns if the given action context is this or a parent of this action context.                                                                                                                                                                       |\n\nA _disposer_ is a function that cancels the effect for which it was created.\n\n# Tips\n\n### Building with production environment\n\nMobX-state-tree provides a lot of dev-only checks. They check the correctness of function calls and perform runtime type-checks over your models. It is recommended to disable them in production builds. To do so, you should use webpack's DefinePlugin to set environment as production and remove them. More information could be found in the [official webpack guides](https://webpack.js.org/plugins/environment-plugin/#usage).\n\n### Generate MST models from JSON\n\nThe following service can generate MST models based on JSON: https://transform.now.sh/json-to-mobx-state-tree\n\n### `optionals` and default value functions\n\n`types.optional` can take an optional function parameter which will be invoked each time a default value is needed. This is useful to generate timestamps, identifiers or even complex objects, for example:\n\n`createdDate: types.optional(types.Date, () => new Date())`\n\n### `toJSON()` for debugging\n\nFor debugging you might want to use `getSnapshot(model, applyPostProcess)` to print the state of a model. If you didn't import `getSnapshot` while debugging in some debugger, don't worry, `model.toJSON()` will produce the same snapshot. (For API consistency, this feature is not part of the typed API).\n\n### Handle circular dependencies between files and types using `late`\n\nIn the exporting file:\n\n```javascript\nexport function LateStore() {\n    return types.model({\n        title: types.string\n    })\n}\n```\n\nIn the importing file:\n\n```javascript\nimport { LateStore } from \"./circular-dep\"\n\nconst Store = types.late(() => LateStore)\n```\n\nThanks to function hoisting in combination with `types.late`, this lets you have circular dependencies between types, across files.\n\nIf you are using TypeScript and you get errors about circular or self-referencing types then you can partially fix it by doing:\n\n```ts\nconst Node = types.model({\n    x: 5, // as an example\n    me: types.maybe(types.late((): IAnyModelType => Node))\n})\n```\n\nIn this case, while \"me\" will become any, any other properties (such as x) will be strongly typed, so you can typecast the self referencing properties (me in this case) once more to get typings. For example:\n\n```ts\nnode.((me) as Instance<typeof Node>).x // x here will be number\n```\n\n### Simulate inheritance by using type composition\n\nThere is no notion of inheritance in MST. The recommended approach is to keep references to the original configuration of a model in order to compose it into a new one, for example by using `types.compose` (which combines two types) or producing fresh types using `.props|.views|.actions`. An example of classical inheritance could be expressed using composition as follows:\n\n```javascript\nconst Square = types\n    .model(\n        \"Square\",\n        {\n            width: types.number\n        }\n    )\n    .views(self => ({\n        surface() {\n            return self.width * self.width\n        }\n    }))\n\n// create a new type, based on Square\nconst Box = Square\n    .named(\"Box\")\n    .views(self => {\n        // save the base implementation of surface\n        const superSurface = self.surface\n\n        return {\n            // super contrived override example!\n            surface() {\n                return superSurface() * 1\n            },\n            volume() {\n                return self.surface * self.width\n            }\n        }\n    }))\n\n// no inheritance, but, union types and code reuse\nconst Shape = types.union(Box, Square)\n```\n\nSimilarly, compose can be used to simply mix in types:\n\n```javascript\nconst CreationLogger = types.model().actions(self => ({\n    afterCreate() {\n        console.log(\"Instantiated \" + getType(self).name)\n    }\n}))\n\nconst BaseSquare = types\n    .model({\n        width: types.number\n    })\n    .views(self => ({\n        surface() {\n            return self.width * self.width\n        }\n    }))\n\nexport const LoggingSquare = types\n    .compose(\n        // combine a simple square model...\n        BaseSquare,\n        // ... with the logger type\n        CreationLogger\n    )\n    // ..and give it a nice name\n    .named(\"LoggingSquare\")\n```\n\n# FAQ\n\n### When not to use MST?\n\nMST provides access to snapshots, patches and interceptable actions. Also, it fixes the `this` problem.\nAll these features have a downside as they incur a little runtime overhead.\nAlthough in many places the MST core can still be optimized significantly, there will always be a constant overhead.\nIf you have a performance critical application that handles a huge amount of mutable data, you will probably be better\noff by using 'raw' MobX, which has a predictable and well-known performance and much less overhead.\n\nLikewise, if your application mainly processes stateless information (such as a logging system), MST won't add much value.\n\n### Where is the `any` type?\n\nMST doesn't offer an any type because it can't reason about it. For example, given a snapshot and a field with `any`, how should MST know how to deserialize it or apply patches to it, etc.? If you need `any`, there are following options:\n\n1.  Use `types.frozen()`. Frozen values need to be immutable and serializable (so MST can treat them verbatim)\n2.  Use volatile state. Volatile state can store anything, but won't appear in snapshots, patches etc.\n3.  If your type is regular, and you just are too lazy to type the model, you could also consider generating the type at runtime once (after all, MST types are just JS...). However, you will loose static typing, and any confusion it causes is up to you to handle :-).\n\n### How does reconciliation work?\n\n-   When applying snapshots, MST will always try to reuse existing object instances for snapshots with the same identifier (see `types.identifier`).\n-   If no identifier is specified, but the type of the snapshot is correct, MST will reconcile objects as well if they are stored in a specific model property or under the same map key.\n-   In arrays, items without an identifier are never reconciled.\n\nIf an object is reconciled, the consequence is that localState is preserved and `afterCreate` / `attach` life-cycle hooks are not fired because applying a snapshot results just in an existing tree node being updated.\n\n### Creating async flows\n\nSee [creating asynchronous flow](docs/async-actions.md).\n\n### Using mobx and mobx-state-tree together\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-render-mobx-state-tree-models-in-react\">egghead.io lesson 5: Render mobx-state-tree Models in React</a></i>\n\nYep, perfectly fine. No problem. Go on. `observer`, `autorun`, etc. will work as expected.\n\n### Should all state of my app be stored in `mobx-state-tree`?\n\nNo, or not necessarily. An application can use both state trees and vanilla MobX observables at the same time.\nState trees are primarily designed to store your domain data as this kind of state is often distributed and not very local.\nFor local component state, for example, vanilla MobX observables might often be simpler to use.\n\n### Can I use Hot Module Reloading?\n\n<i><a style=\"color: white; background:cornflowerblue;padding:5px;margin:5px;border-radius:2px\" href=\"https://egghead.io/lessons/react-restore-the-model-tree-state-using-hot-module-reloading-when-model-definitions-change\">egghead.io lesson 10: Restore the Model Tree State using Hot Module Reloading when Model Definitions Change</a></i>\n\nYes, with MST it is pretty straight forward to setup hot reloading for your store definitions while preserving state. See the [todomvc example](https://github.com/mobxjs/mobx-state-tree/blob/745904101fdaeb51f16f40ebb80cd7fecf742572/packages/mst-example-todomvc/src/index.js#L60-L64).\n\n### TypeScript and MST\n\nTypeScript support is best-effort as not all patterns can be expressed in TypeScript. Except for assigning snapshots to properties we get pretty close! As MST uses the latest fancy TypeScript features it is required to use TypeScript 3.0 or later with `noImplicitThis` and `strictNullChecks` enabled.\nActually, the more strict options that are enabled, the better the type system will behave. \n\n#### Recommend compiler flags\n\nThe recommended compiler flags (against which all our tests are written) are:\n\n```json\n{\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noImplicitThis\": true\n}\n```\n\nOr shorter by leveraging `strict`:\n\n```json\n{\n  \"strict\": true,\n  \"noImplicitReturns\": true\n}\n```\n\nFlow is not supported.\n\n#### Using a MST type at design time\n\nWhen using models, you write an interface, along with its property types, that will be used to perform type checks at runtime.\nWhat about compile time? You can use TypeScript interfaces to perform those checks, but that would require writing again all the properties and their actions!\n\nGood news! You don't need to write it twice!\n\nThere are four kinds of types available, plus one helper type:\n\n-   `Instance<typeof TYPE>` or `Instance<typeof VARIABLE>` is the node instance type. (Legacy form is `typeof MODEL.Type`).\n-   `SnapshotIn<typeof TYPE>` or `SnapshotIn<typeof VARIABLE>` is the input (creation) snapshot type. (Legacy form is `typeof MODEL.CreationType`).\n-   `SnapshotOut<typeof TYPE>` or `SnapshotOut<typeof VARIABLE>` is the output (creation) snapshot type. (Legacy form is `typeof MODEL.SnapshotType`).\n-   `SnapshotOrInstance<typeof TYPE>` or `SnapshotOrInstance<typeof VARIABLE>` is `SnapshotIn<T> | Instance<T>`. This type is useful when you want to declare an input parameter that is able consume both types.\n-   `TypeOfValue<typeof VARIABLE>` gets the original type for the given instance. Note that this only works for complex values (models, arrays, maps...) but not for simple values (number, string, boolean, string, undefined).\n\n```typescript\nconst Todo = types\n    .model({\n        title: \"hello\"\n    })\n    .actions(self => ({\n        setTitle(v: string) {\n            self.title = v\n        }\n    }))\n\ntype ITodo = Instance<typeof Todo> // => { title: string; setTitle: (v: string) => void }\n\ntype ITodoSnapshotIn = SnapshotIn<typeof Todo> // => { title?: string }\n\ntype ITodoSnapshotOut = SnapshotOut<typeof Todo> // => { title: string }\n```\n\nDue to the way typeof operator works, when working with big and deep models trees, it might make your IDE/ts server takes a lot of CPU time and freeze vscode (or others).\nA solution for this is to turn the types into interfaces. \nThis way of defining types enables TypeScript to better cope with circular type definitions as well.\n\n```ts\ninterface ITodo extends Instance<typeof Todo> {}\ninterface ITodoSnapshotIn extends SnapshotIn<typeof Todo> {}\ninterface ITodoSnapshotOut extends SnapshotOut<typeof Todo> {}\n```\n\n#### Typing `self` in actions and views\n\nThe type of `self` is what `self` was **before the action or views blocks starts**, and only after that part finishes, the actions will be added to the type of `self`.\n\nSometimes you'll need to take into account where your typings are available and where they aren't. The code below will not compile: TypeScript will complain that `self.upperProp` is not a known property. Computed properties are only available after `.views` is evaluated.\n\nFor example:\n\n```typescript\nconst Example = types\n    .model(\"Example\", {\n        prop: types.string\n    })\n    .views(self => ({\n        get upperProp(): string {\n            return self.prop.toUpperCase()\n        },\n        get twiceUpperProp(): string {\n            return self.upperProp + self.upperProp // Compile error: `self.upperProp` is not yet defined\n        }\n    }))\n```\n\nYou can circumvent this situation by using `this` whenever you intend to use the newly declared computed values that are local to the current object:\n\n```typescript\nconst Example = types.model(\"Example\", { prop: types.string }).views(self => ({\n    get upperProp(): string {\n        return self.prop.toUpperCase()\n    },\n    get twiceUpperProp(): string {\n        return this.upperProp + this.upperProp\n    }\n}))\n```\n\nAlternatively you can also declare multiple `.views` block, in which case the `self` parameter gets extended after each block.\n\n```typescript\nconst Example = types\n  .model('Example', { prop: types.string })\n  .views(self => {\n    get upperProp(): string {\n      return self.prop.toUpperCase();\n    },\n  }))\n  .views(self => ({\n    get twiceUpperProp(): string {\n      return self.upperProp + self.upperProp;\n    },\n  }));\n```\n\nAs a last resort, although not recommended due to the performance penalty (see the note below), you may declare the views in two steps:\n\n```typescript\nconst Example = types\n  .model('Example', { prop: types.string })\n  .views(self => {\n      const views = {\n        get upperProp(): string {\n            return self.prop.toUpperCase();\n        },\n        get twiceUpperProp(): string {\n            return views.upperProp + views.upperProp;\n        }\n      }\n      return views\n  }))\n```\n\n_**NOTE: the last approach will incur runtime performance penalty as accessing such computed values (e.g. inside `render()` method of an observed component) always leads to full recompute (see [this issue](https://github.com/mobxjs/mobx-state-tree/issues/818#issue-323164363) for details). For a heavily used computed properties it's recommended to use one of above approaches.**_\n\nSimilarly, when writing actions or views one can use helper functions:\n\n```typescript\nimport { types, flow } from \"mobx-state-tree\"\n\nconst Example = types.model(\"Example\", { prop: types.string }).actions(self => {\n    // Don't forget that async operations HAVE\n    // to use `flow( ... )`.\n    const fetchData = flow(function* fetchData() {\n        yield doSomething()\n    })\n\n    return {\n        fetchData,\n        afterCreate() {\n            // Notice that we call the function directly\n            // instead of using `self.fetchData()`. This is\n            // because Typescript doesn't know yet about `fetchData()`\n            // being part of `self` in this context.\n            fetchData()\n        }\n    }\n})\n```\n\n#### Snapshots can be used to write values\n\nEverywhere where you can modify your state tree and assign a model instance, you can also\njust assign a snapshot, and MST will convert it to a model instance for you.\nHowever, that is simply not expressible in static type systems atm (as the type written to a value differs to the type read from it).\nAs a workaround MST offers a `cast` function, which will try to fool the typesystem into thinking that an snapshot type (and instance as well)\nis of the related instance type.\n\n```typescript\nconst Task = types.model({\n    done: false\n})\nconst Store = types.model({\n    tasks: types.array(Task),\n    selection: types.maybe(Task)\n})\n\nconst s = Store.create({ tasks: [] })\n// `{}` is a valid snapshot of Task, and hence a valid task, MST allows this, but TS doesn't, so we need to use 'cast'\ns.tasks.push(cast({}))\ns.selection = cast({})\n```\n\nAdditionally, for function parameters, MST offers a `SnapshotOrInstance<T>` type, where T can either be a `typeof TYPE` or a\n`typeof VARIABLE`. In both cases it will resolve to the union of the input (creation) snapshot and instance type of that TYPE or VARIABLE.\n\nUsing both at the same time we can express property assignation of complex properties in this form:\n\n```typescript\nconst Task = types.model({\n    done: false\n})\nconst Store = types\n    .model({\n        tasks: types.array(Task)\n    })\n    .actions(self => ({\n        addTask(task: SnapshotOrInstance<typeof Task>) {\n            self.tasks.push(cast(task))\n        },\n        replaceTasks(tasks: SnapshotOrInstance<typeof self.tasks>) {\n            self.tasks = cast(tasks)\n        }\n    }))\n\nconst s = Store.create({ tasks: [] })\n\ns.addTask({})\n// or\ns.addTask(Task.create({}))\n\ns.replaceTasks([{ done: true }])\n// or\ns.replaceTasks(types.array(Task).create([{ done: true }]))\n```\n\nAdditionally, the `castToSnapshot` function can be also used in the inverse case, this is when you want to use an instance inside an snapshot.\nIn this case MST will internally convert the instance to a snapshot before using it, but we need once more to fool TypeScript into\nthinking that this instance is actually a snapshot.\n\n```typescript\nconst task = Task.create({ done: true })\nconst Store = types.model({\n    tasks: types.array(Task)\n})\n\n// we cast the task instance to a snapshot so it can be used as part of another snapshot without typing errors\nconst s = Store.create({ tasks: [castToSnapshot(task)] })\n```\n\nFinally, the `castToReferenceSnapshot` can be used when we want to use an instance to actually use a reference snapshot (a string or number).\nIn this case MST will internally convert the instance to a reference snapshot before using it, but we need once more to fool TypeScript into\nthinking that this instance is actually a snapshot of a reference.\n\n```typescript\nconst task = Task.create({ id: types.identifier, done: true })\nconst Store = types.model({\n    tasks: types.array(types.reference(Task))\n})\n\n// we cast the task instance to a reference snapshot so it can be used as part of another snapshot without typing errors\nconst s = Store.create({ tasks: [castToReferenceSnapshot(task)] })\n```\n\n#### Known Typescript Issue 5938\n\nThere is a known issue with typescript and interfaces as described by: https://github.com/Microsoft/TypeScript/issues/5938\n\nThis rears its ugly head if you try to define a model such as:\n\n```typescript\nimport { types } from \"mobx-state-tree\"\n\nexport const Todo = types.model({\n    title: types.string\n})\n\nexport type ITodo = typeof Todo.Type\n```\n\nAnd you have your tsconfig.json settings set to:\n\n```json\n{\n  \"compilerOptions\": {\n    ...\n    \"declaration\": true,\n    \"noUnusedLocals\": true\n    ...\n  }\n}\n```\n\nThen you will get errors such as:\n\n> error TS4023: Exported variable 'Todo' has or is using name 'IModelType' from external module \"...\" but cannot be named.\n\nUntil Microsoft fixes this issue the solution is to re-export IModelType:\n\n```typescript\nimport { types, IModelType } from \"mobx-state-tree\"\n\nexport type __IModelType = IModelType<any, any>\n\nexport const Todo = types.model({\n    title: types.string\n})\n\nexport type ITodo = typeof Todo.Type\n```\n\nIt ain't pretty, but it works.\n\n#### Optional/empty maps/arrays\n\nSince v3, maps and arrays are optional by default, this is:\n\n```javascript\ntypes.map(OtherType)\n// is the same as\ntypes.optional(types.map(OtherType), {})\n\ntypes.array(OtherType)\n// is the same as\ntypes.optional(types.array(OtherType), [])\n```\n\n#### `.shift()/.pop()`'ing last item of `types.array(PRIMITIVE_TYPE)` does not return correct value\n\n```javascript\nconst array = types.array(types.number).create([1, 2])\narray.shift() // will return 1\narray.shift() // will return ScalarNode\n```\n\nThis is a mobx bug, which was fixed in version 4.8.0/5.8.0. Please upgrade you peer dependency to corresponding version to get expected value.\n\n### How does MST compare to Redux\n\nSo far this might look a lot like an immutable state tree as found for example in Redux apps, but there're are only so many reasons to use Redux as per [article linked at the very top of Redux guide](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) that MST covers too, meanwhile:\n\n-   Like Redux, and unlike MobX, MST prescribes a very specific state architecture.\n-   mobx-state-tree allows direct modification of any value in the tree. It is not necessary to construct a new tree in your actions.\n-   mobx-state-tree allows for fine-grained and efficient observation of any point in the state tree.\n-   mobx-state-tree generates JSON patches for any modification that is made.\n-   mobx-state-tree provides utilities to turn any MST tree into a valid Redux store.\n-   Having multiple MSTs in a single application is perfectly fine.\n\n## Contributing\n\nExtensive pull requests are best discussed in an issue first.\n\nSetting up the environment:\n\n1.  Clone this repository\n2.  `yarn` is the package manager of choice (with workspaces support enabled). Make sure to run Node 8 or higher.\n3.  Run `yarn install` on the root.\n4.  Editor settings are optimized for VS Code, so just run `code .` in the root folder. Debugger settings are included in the project.\n\nFor `mobx-state-tree`:\n\n1.  Go to `packages/mobx-state-tree` and run `yarn jest` to ensure all tests pass.\n2.  After updating jsdocs, better run `yarn build-docs` in `packages/mobx-state-tree` to regenerate them.\n\nFor `mst-middlewares`:\n\n1.  Go to `packages/mst-middlewares` and run `yarn jest` to ensure all tests pass.\n2.  If your changes depend on a change in `packages/mobx-state-tree` you will need to run `yarn buld` there first!\n\nOnce you think your PR is ready:\n\n1.  Run on the root `yarn build` to ensure it all builds.\n2.  Run on the root `yarn test` to ensure all tests pass.\n3.  Create the PR on GitHub.\n4.  Check the CI build passes on the PR thread in GitHub.\n\nHave fun!\n\n## Thanks!\n\n-   [Mendix](https://mendix.com) for sponsoring and providing the opportunity to work on exploratory projects like MST.\n-   [Dan Abramov](https://twitter.com/dan_abramov)'s work on [Redux](http://redux.js.org) has strongly influenced the idea of snapshots and transactional actions in MST.\n-   [Giulio Canti](https://twitter.com/GiulioCanti)'s work on [tcomb](http://github.com/gcanti/tcomb) and type systems in general has strongly influenced the type system of MST.\n-   All the early adopters encouraging to pursue this whole idea and proving it is something feasible.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mobxjs/mobx-state-tree.git"
  },
  "scripts": {
    "_prepublish": "yarn build && yarn build-docs",
    "build": "yarn clean && shx cp ../../README.md . && tsc && cpr lib dist --filter=\\.js$ && rollup -c",
    "build-docs": "shx rm -rf ../../docs/API && typedoc --options ./typedocconfig.js && yarn fix-docs",
    "clean": "shx rm -rf dist && shx rm -rf lib",
    "fix-docs": "concat -o ../../docs/API/README.md ../../docs/API_header.md ../../docs/API/README.md",
    "jest": "jest --testPathPattern=/__tests__/core/",
    "jest:perf": "jest --testPathPattern=/__tests__/perf/",
    "lint": "tslint -c ./tslint.json 'src/**/*.ts'",
    "test": "yarn test:dev && yarn test:prod && yarn test:others",
    "test:cyclic": "node -e \"require('.')\"",
    "test:dev": "cross-env NODE_ENV=development JEST_JUNIT_OUTPUT=../../test-results/mobx-state-tree/dev.xml yarn jest",
    "test:mobx4": "yarn add -D mobx@4.9.0 && cross-env JEST_JUNIT_OUTPUT=../../test-results/mobx-state-tree/mobx4.xml yarn jest -i && git checkout package.json ../../yarn.lock && yarn install",
    "test:others": "yarn test:cyclic && yarn test:mobx4",
    "test:perf": "yarn build && yarn jest:perf && TS_NODE_COMPILER_OPTIONS='{\"module\": \"commonjs\"}' /usr/bin/time node --expose-gc --require ts-node/register __tests__/perf/report.ts",
    "test:prod": "cross-env NODE_ENV=production JEST_JUNIT_OUTPUT=../../test-results/mobx-state-tree/prod.xml yarn jest"
  },
  "typings": "dist/index.d.ts",
  "umd:main": "dist/mobx-state-tree.umd.js",
  "unpkg": "dist/mobx-state-tree.umd.min.js",
  "version": "3.14.1"
}
